'''
-- Methods/Functions
    "allSpanningTrees",
    "basisForFlowPolytope",
    "bipartiteQuiver",
    "chainQuiver",
    "coneSystem",
    "flowPolytope",
    "incInverse",
    "isAcyclic",
    "isClosedUnderArrows",
    "isSemistable",
    "isStable",
    "isTight",
    "makeTight",
    "maxCodimensionUnstable",
    "maximalNonstableSubquivers",
    "maximalUnstableSubquivers",
    "mergeOnArrow",
    "mergeOnVertex",
    "potentialWalls",
    "primitiveArrows",
    "quiverConnectivityMatrix",
    "quiverEdges",
    "quiverFlow",
    "quiverWeights",
    "referenceThetas",
    "sameChamber",
    "stableTrees",
    "subquivers",
    "theta",
    "threeVertexQuiver",
    "wallType",

    "toricQuiver"
}
'''


def toricQuiver(edges, weight=None):
    
def allSpanningTrees(Q):

def basisForFlowPolytope(Q, spanningTree=None):

def bipartiteQuiver(n, m):

def chainQuiver(l):

def coneSystem(Q):

def flowPolytope(Q, weight=None):

def incInverse(Q, theta):

def isAcyclic(Q):

def isClosedUnderArrows(V, Q):

def isSemistable(SQ, Q):

def isStable(SQ, Q):

def isTight(Q):

def makeTight(Q, theta):

def maxCodimensionUnstable(Q):

def maximalNonstableSubquivers(Q):

def maximalUnstableSubquivers(Q):

def mergeOnArrow(Q1,a1,Q2,a2):

def mergeOnVertex(Q1,v1,Q2,v2):

def potentialWalls(Q, theta)

def primitiveArrows(Q):

def referenceThetas(CQ):

def sameChamber(theta1, theta2, CQ):

def stableTrees(Q, weight):

def subquivers(Q):

def theta(Q):

def threeVertexQuiver(a,b,c):

def wallType(W):

quiverConnectivityMatrix
quiverEdges
quiverFlow
quiverWeights

